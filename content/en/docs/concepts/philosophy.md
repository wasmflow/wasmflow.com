---
title: "Our Philosophy"
linkTitle: "Philosophy"
weight: 2
description: >
  Acknowledging the reality of software.
---

### Software is easy to create. Applications are not.

Developers have an endless supply of languages to choose from when starting a project. Java, JavaScript, Python, Ruby, C, C++, C#, Rust, Go, Haskell, PHP, VisualBasic, Swift, Dart, TypeScript, COBOL, Kotlin, Julia, Scala, Lisp, Lua, Fortran, Clojure, Erlang, Perl and [the list really does go on and on](https://en.wikipedia.org/wiki/List_of_programming_languages).

Each language takes a different path to the same destination. Each try to make creating valuable software easy. Not software that is worth a lot of money, mind you. Software that users value. Without users, software is worthless.

The more value you try to provide, the more complex software gets. Every switch, button, option, and feature you add makes it harder to develop the next. We can't avoid that and we shouldn't try. We shouldn't make concessions on what we want because it's difficult.

### Application developers are different from library developers

Application developers engineer solutions for end users while a library developers's end user is an application developer. Programmers frequently fall on a gradient somewhere between both disciplines and they switch hats as necessary. The root of our problem stems from the variables that both sides have to manage. Library developers have concrete, well-defined contracts with limited scope and they invent algorithms that deliver dense chunks of value. Think decoding an animation frame into individual pixels. The inputs, outputs, and success criteria are clear.

Application developers however, don't know what success looks like. Application developers operate in a test, measure, and adapt loop. This is fundamentally a different environment to work in. Both types of developers produce immense value, but they do so using the same tools designed for library developers. The infinite capability of most programming languages leads to bespoke implementations that are difficult to adapt and impossible to reuse.

### Wasmflow is a platform for application developers

The Wasmflow runtime stitches together libraries without needing a code layer. Rather than integrate a library with source code, you connect it via configuration in schematics. The result is a platform that can be molded instantly without rebuilding or rearchitecting anything. Results are easier to test, measure and scale. In short, it costs less to iterate. Wasmflow absorbs the complexity of a scalable, adaptable platform so you can move faster.
